"""
Knowledge Base Search Service

Provides full-text search over ingested documents using SQLite FTS5 with BM25 ranking.
The knowledge database is generated by scripts/ingest_knowledge.py and deployed to the Pi.
"""

import os
import sqlite3
from typing import List, Dict, Optional
from loguru import logger
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from models.settings import AppSetting


# Default path on the Pi
DEFAULT_KB_PATH = "/opt/isaac/backend/data/knowledge.db"
DEFAULT_KB_PATH_DEV = "/opt/isaac/backend/data/knowledge.db"

# Cache the connection to avoid reopening on every query
_kb_conn: Optional[sqlite3.Connection] = None
_kb_path: Optional[str] = None


def _get_kb_path() -> str:
    """Determine the knowledge base path based on environment."""
    from config import settings
    if settings.is_dev_instance:
        return DEFAULT_KB_PATH_DEV
    return DEFAULT_KB_PATH


def _get_connection(db_path: str = None) -> Optional[sqlite3.Connection]:
    """Get or create a cached SQLite connection to the knowledge base."""
    global _kb_conn, _kb_path

    if db_path is None:
        db_path = _get_kb_path()

    # Reuse if same path
    if _kb_conn is not None and _kb_path == db_path:
        return _kb_conn

    # Close old connection
    if _kb_conn is not None:
        try:
            _kb_conn.close()
        except Exception:
            pass
        _kb_conn = None

    if not os.path.exists(db_path):
        return None

    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        conn.row_factory = sqlite3.Row
        # Read-only mode for safety
        conn.execute("PRAGMA query_only = ON")
        _kb_conn = conn
        _kb_path = db_path
        logger.info(f"Knowledge base loaded: {db_path}")
        return conn
    except Exception as e:
        logger.error(f"Failed to open knowledge base: {e}")
        return None


def search_chunks(query: str, limit: int = 5, category: str = None) -> List[Dict]:
    """
    Search the knowledge base using FTS5 BM25 ranking.

    Args:
        query: Search query (natural language)
        limit: Maximum number of results
        category: Optional category filter

    Returns:
        List of matching chunks with metadata
    """
    conn = _get_connection()
    if conn is None:
        return []

    try:
        # Build FTS5 query - escape special characters and create search terms
        search_terms = _build_fts_query(query)
        if not search_terms:
            return []

        if category:
            sql = """
                SELECT content, source_file, category, chunk_index,
                       rank AS relevance
                FROM chunks
                WHERE chunks MATCH ?
                AND category = ?
                ORDER BY rank
                LIMIT ?
            """
            rows = conn.execute(sql, (search_terms, category, limit)).fetchall()
        else:
            sql = """
                SELECT content, source_file, category, chunk_index,
                       rank AS relevance
                FROM chunks
                WHERE chunks MATCH ?
                ORDER BY rank
                LIMIT ?
            """
            rows = conn.execute(sql, (search_terms, limit)).fetchall()

        results = []
        for row in rows:
            results.append({
                "content": row["content"],
                "source": row["source_file"],
                "category": row["category"],
                "chunk": int(row["chunk_index"]),
                "relevance": float(row["relevance"]),
            })

        return results

    except Exception as e:
        logger.error(f"Knowledge base search failed: {e}")
        return []


def _build_fts_query(query: str) -> str:
    """
    Convert a natural language query into an FTS5 search expression.
    Extracts meaningful words and joins with OR for broad matching.
    """
    import re

    # Remove special FTS5 characters
    cleaned = re.sub(r'[^\w\s]', ' ', query.lower())

    # Split into words, filter short ones and stop words
    stop_words = {
        'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
        'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
        'should', 'may', 'might', 'can', 'shall', 'to', 'of', 'in', 'for',
        'on', 'with', 'at', 'by', 'from', 'as', 'into', 'about', 'between',
        'through', 'during', 'before', 'after', 'above', 'below', 'and', 'or',
        'but', 'not', 'no', 'if', 'then', 'than', 'too', 'very', 'just',
        'also', 'how', 'what', 'when', 'where', 'which', 'who', 'why',
        'this', 'that', 'these', 'those', 'it', 'its', 'my', 'your', 'his',
        'her', 'our', 'their', 'me', 'him', 'them', 'we', 'you', 'i',
    }

    words = [w for w in cleaned.split() if len(w) > 2 and w not in stop_words]

    if not words:
        return ""

    # Use OR to match any of the terms (broader matching)
    # FTS5 default is AND, but OR gives better recall for natural language queries
    return " OR ".join(words)


def get_kb_stats() -> Optional[Dict]:
    """Get knowledge base statistics."""
    conn = _get_connection()
    if conn is None:
        return None

    try:
        stats = {}
        rows = conn.execute("SELECT key, value FROM metadata").fetchall()
        for row in rows:
            stats[row["key"]] = row["value"]

        # Get category counts
        cat_rows = conn.execute(
            "SELECT category, COUNT(*) as count FROM sources GROUP BY category"
        ).fetchall()
        stats["categories"] = {row["category"]: row["count"] for row in cat_rows}

        return stats
    except Exception as e:
        logger.error(f"Failed to get KB stats: {e}")
        return None


async def search_knowledge_base(db: AsyncSession, query: str, limit: int = 4) -> str:
    """
    Search the knowledge base and format results as context for the AI.
    Checks if the feature is enabled in settings first.

    Args:
        db: Database session (for reading settings)
        query: User's message/question
        limit: Max results to include

    Returns:
        Formatted context string, or empty string if disabled/no results
    """
    # Check if knowledge base is enabled
    result = await db.execute(
        select(AppSetting).where(AppSetting.key == "knowledge_base_enabled")
    )
    setting = result.scalar_one_or_none()
    if not setting or setting.value != "true":
        return ""

    # Optional: check for custom path
    result = await db.execute(
        select(AppSetting).where(AppSetting.key == "knowledge_base_path")
    )
    path_setting = result.scalar_one_or_none()
    custom_path = path_setting.value if path_setting and path_setting.value else None

    if custom_path:
        conn = _get_connection(custom_path)
    else:
        conn = _get_connection()

    if conn is None:
        return ""

    chunks = search_chunks(query, limit=limit)
    if not chunks:
        return ""

    # Format as context
    lines = ["REFERENCE MATERIAL (from knowledge base):"]
    for i, chunk in enumerate(chunks, 1):
        source = chunk["source"]
        category = chunk["category"]
        lines.append(f"\n[Source {i}: {source} ({category})]")
        lines.append(chunk["content"])

    context = "\n".join(lines)

    # Trim to reasonable size (roughly 3000 chars max to leave room for other context)
    if len(context) > 3000:
        context = context[:2950] + "\n...(truncated)"

    logger.debug(f"KB search for '{query[:50]}...' returned {len(chunks)} results")
    return context


def close_connection():
    """Close the cached knowledge base connection."""
    global _kb_conn, _kb_path
    if _kb_conn is not None:
        try:
            _kb_conn.close()
        except Exception:
            pass
        _kb_conn = None
        _kb_path = None
